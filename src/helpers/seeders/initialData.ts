import { Injectable } from "@nestjs/common";
import { hash } from "bcrypt";
import { Metadata, Permission, Role, User } from "src/entities";
import { PermissionAction } from "src/enums/permissions.enum";
import { TablesNames } from "src/enums/tables.enum";
import { UserRole } from "src/enums/userRole.enum";
import { DataSource, Not } from "typeorm";

// These are initial data should exist so the app would work

@Injectable()
export class InitialDataSeederService {
    constructor(private readonly dataSource: DataSource) {}

    private async seedMetadata() {
        console.log("ðŸš€ Seeding Metadata table with INITIAL DATA...");

        const repo = this.dataSource.getRepository(Metadata);

        const existing = await repo.findOneBy({ id: 1 });

        if (!existing) {
            const metadata = repo.create({
                id: 1,
                name: "Raven",
                logo: "/logo.png",
                phoneNumber: "788424973",
                slogan: "Generated By Raven Nest @ https://www.npmjs.com/package/@kaiserleap/raven",
            });

            await repo.upsert(metadata, ["id"]);

            console.log(
                "ðŸŸ¢ Seeding Metadata table with INITIAL DATA is done successfully."
            );
        } else {
            console.log(
                "ðŸŸ¨ Seeding Metadata table with INITIAL DATA was done earlier."
            );
        }
    }

    private async seedRole(role) {
        console.log(`ðŸš€ Seeding Role table with INITIAL DATA of ${role}...`);

        const repo = this.dataSource.getRepository(Role);

        const existingRole = await repo.findOneBy({
            name: role,
        });

        if (!existingRole) {
            const roleData = repo.create({
                name: role,
            });

            await repo.save(roleData);

            console.log(
                `ðŸŸ¢ Seeding Role table with INITIAL DATA of ${role} is done successfully.`
            );
        } else {
            console.log(
                `ðŸŸ¨ Seeding Role table with INITIAL DATA of ${role} was done earlier.`
            );
        }
    }

    private async seedBasicRoles() {
        console.log("ðŸš€ Seeding Role table with INITIAL DATA...");

        const rolesToSeed = [UserRole.ADMIN, UserRole.PUBLIC];

        for (const role of rolesToSeed) {
            await this.seedRole(role);
        }
    }

    private async seedInitialPermissions() {
        console.log("ðŸš€ Seeding Permission table with INITIAL DATA...");

        const permissions: {
            action: PermissionAction;
            table: TablesNames;
            role: Role;
        }[] = [];

        const repo = this.dataSource.getRepository(Permission);

        const tables = Object.values(TablesNames).filter((table) => {
            switch (table) {
                case "role":
                case "permission":
                case "user":
                case "health-check":
                    return false;
                default:
                    return true;
            }
        });

        const actions = Object.values(PermissionAction).filter((table) => {
            switch (table) {
                case "delete":
                    return false;
                default:
                    return true;
            }
        });

        const rolesRepo = this.dataSource.getRepository(Role);
        const authRoles = await rolesRepo.find({
            where: { name: Not(UserRole.PUBLIC) },
        });

        tables?.forEach(async (table) => {
            actions?.forEach(async (action) => {
                authRoles?.forEach(async (role) => {
                    permissions.push({
                        action,
                        table,
                        role,
                    });
                });
            });
        });

        const publicRole = await rolesRepo.findOneBy({
            name: UserRole.PUBLIC,
        });

        if (publicRole) {
            const customPermissions = [
                {
                    role: publicRole,
                    table: TablesNames.METADATA,
                    action: PermissionAction.GET_ALL,
                },
                {
                    role: publicRole,
                    table: TablesNames.METADATA,
                    action: PermissionAction.GET_ONE,
                },
                {
                    role: publicRole,
                    table: TablesNames.AUTH,
                    action: PermissionAction.CREATE,
                },

                {
                    role: publicRole,
                    table: TablesNames.HEALTH_CHECK,
                    action: PermissionAction.GET_ALL,
                },
                {
                    role: publicRole,
                    table: TablesNames.HEALTH_CHECK,
                    action: PermissionAction.GET_ONE,
                },
            ];

            customPermissions.forEach((per) => permissions.push(per));
        }

        authRoles.forEach((role) =>
            permissions.push({
                action: PermissionAction.DELETE,
                table: TablesNames.FILE,
                role,
            })
        );

        for (const permission of permissions) {
            const { role, action, table } = permission;

            const existing = await repo.findOne({
                where: {
                    role: { id: role.id },
                    action,
                    table,
                },
                relations: ["role"],
            });

            const description =
                "Allowing " +
                role.name +
                " to " +
                action +
                " @ " +
                table +
                " table.";
            if (!existing) {
                console.log(
                    `ðŸš€ Seeding Permission table with INITIAL DATA of ${description}...`
                );

                const permissionData = repo.create({
                    action,
                    table,
                    description,
                    role,
                });

                await repo.save(permissionData);

                console.log(
                    `ðŸŸ¢ Seeding Permission table with INITIAL DATA of ${description} is done successfully.`
                );
            } else {
                console.log(
                    `ðŸŸ¨ Seeding Permission table with INITIAL DATA of ${description} was done earlier.`
                );
            }
        }
    }

    private async seedUser({
        user: { email = "", role = UserRole.ADMIN, password = "" },
    }) {
        console.log(`ðŸš€ Seeding User table with INITIAL DATA of ${email}...`);

        const userRepo = this.dataSource.getRepository(User);

        const existing = await userRepo.findOneBy({ email });

        if (!existing) {
            const userData = userRepo.create({
                password,
                email,
                role,
            });

            const user = await userRepo.save(userData);

            console.log(
                `ðŸŸ¢ Seeding User table with INITIAL DATA of ${email} is done successfully.`
            );
        } else {
            console.log(
                `ðŸŸ¨ Seeding User table with INITIAL DATA of ${email} was done earlier.`
            );
        }
    }

    private async seedUsers() {
        console.log("ðŸš€ Seeding User table with INITIAL DATA...");

        const usersToSeed = [
            {
                user: {
                    password: await hash("s5Rsa2?#sd1154", 12),
                    role: UserRole.ADMIN,
                    email: "example@example.com",
                },
            },
        ];

        for (const user of usersToSeed) {
            await this.seedUser(user);
        }
    }

    async seed() {
        console.log("ðŸš€ðŸš€ Seeding tables with INITIAL DATA...");

        await this.seedMetadata();

        await this.seedBasicRoles();

        await this.seedInitialPermissions();

        await this.seedUsers();

        console.log("âœ… All tables seeded with INITIAL DATA successfully.");
    }
}
